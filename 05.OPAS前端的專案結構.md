# OPAS 前端的專案結構介紹

---

## 1. 根目錄結構

```bash
.
├─ index.html                 # 入口 HTML
├─ vite.config.ts             # Vite 設定（含 Quasar plugin）
├─ tsconfig*.json             # TypeScript 設定
├─ package.json               # 專案相依套件與 script
├─ eslint.config.js           # ESLint 設定
├─ postcss.config.js          # PostCSS 設定
├─ tailwind.config.js         # Tailwind CSS 設定
├─ data.json                  # 本地假資料 / 設定（看內容）
├─ dist/                      # 打包後輸出的靜態檔
└─ src/                       # 前端程式主要目錄
```

## 2. src 目錄結構
```bash

src
├─ main.ts                    # Vue 3 進入點
├─ App.vue                    # Root component
├─ style.css                  # 全域樣式
├─ quasar-variables.sass      # Quasar 主題變數
├─ vite-env.d.ts              # Vite/TS 環境宣告
├─ shims-vue.d.ts             # Vue 元件型別宣告
│
├─ assets/                    # 靜態資源 (logo / 圖片)
│  ├─ vue.svg
│  ├─ YTEC_BG.png
│  ├─ YTEC_BOTTOM.png
│  ├─ YTEC_ICON_v2.png
│  └─ ytec_180_bg.jpg
│
├─ components/                # 共用元件
│  ├─ BarChart.vue
│  ├─ BarChart2.vue
│  ├─ PieChart.vue
│  ├─ EQEntityPieChart.vue
│  ├─ OPTable.vue
│  ├─ OPCalendar.vue
│  ├─ OPInput.vue
│  ├─ OPMonthPicker.vue
│  ├─ QMultiSelect.vue
│  ├─ QSingleSelect.vue
│  ├─ NTable.vue
│  ├─ RTable.vue
│  ├─ CfmMenu.vue
│  ├─ CfmLoadingDialog.vue
│  ├─ IndexMenu.vue
│  └─ models.ts               # 一些型別/介面定義
│
├─ composable/                # 組合式函式 (Composition API hooks)
│  ├─ useAjax.ts
│  └─ useTask.ts              # 你前面用到的 request / requestSearch 在這裡
│
├─ directives/                # 自訂 Vue 指令
│  └─ resize.ts
│
├─ routes/                    # Vue Router 設定
│  ├─ index.ts                # Router 建立：routes、scrollBehavior（你選到的那行）
│  └─ map.json                # route 對應設定 / 權限表 (依內容)
│
├─ utils/                     # 工具函式
│  ├─ index.ts                # 共用 util（像 requestURL 之類的）
│  ├─ event.ts
│  ├─ ResizeTable.ts
│  └─ konst.ts                # 常數設定
│
└─ pages/                     # 各功能頁面（OPAS系統，按照後端專案分類）
   ├─ APQP/
   ├─ CFM/
   ├─ CFPAnalysis/
   ├─ EQP/
   ├─ FM/
   ├─ HumanAnalysis/
   ├─ LEDIO/
   ├─ LEDPPI/
   ├─ LEDUU/
   ├─ OEE/
   ├─ OPASPageViews/
   ├─ ProductDashboard/
   └─ Testdashboard/
```

## 3. 專案常用的套件

- 1. Quasar 
    [https://quasar.dev/](https://quasar.dev/)
- 2. jquery
    [https://jquery.com/](https://jquery.com/)
- 3. vue-echarts
    [https://github.com/ecomfe/vue-echarts](https://github.com/ecomfe/vue-echarts)
- 4. echarts
    [https://echarts.apache.org/en/index.html](https://echarts.apache.org/en/index.html)
- 5. numbro
    [https://numbrojs.com/](https://numbrojs.com/)
- 6. axios
    [https://axios-http.com/](https://axios-http.com/)

## 4. 專案開發流程

1. 先在 `src/pages/` 下建立新的資料夾，命名為後端專案名稱（如 `TestPPI`）。
2. 在該資料夾下建立 `FocusCustomer.vue`，作為該專案的入口頁面。
3. 在 `src/routes/map.json` 中，新增該專案的路由設定。

```json
{
  "TestPPI": [
    {
      "path": "/Default/FocusCustomer",           // 這次開發要替換的頁面路徑
      "component": "../pages/TestPPI/FocusCustomer.vue"
    }
  ]
}
```
4. 在 `.env` 檔案中，新增該專案的設定（如 `VITE_PROJECT=TestPPI`，以及`VITE_MVC_PORT=53546`）。
5. 在終端機中，執行 `pnpm run dev`，啟動開發伺服器。
6. 開啟瀏覽器，輸入 `http://localhost:5173/Default/FocusCustomer`，即可看到該頁面。

## 5. 取得後端資料

取得選單資料(或者接API數據)，主要透過 `src/composable/useTask.ts` 中的 `request` 函式，如下：

```ts
// src/composable/useTask.ts
import { ref } from "vue";
import axios, { AxiosResponse, AxiosRequestConfig } from "axios";

export const useAxios = () => {
  const controller = ref<AbortController | null>(null);
  const isLoading = ref(false);
  const error = ref<Error | null>(null);

  const cancelSignal = () => {
    if (controller.value) {
      controller.value.abort();
      controller.value = null;
    }
  };

  const request = async (config: AxiosRequestConfig) => {
    if (controller.value) controller.value.abort();
    controller.value = new AbortController();
    isLoading.value = true;
    try {
      const res = await axios({
        ...config,
        signal: controller.value.signal,
      });
      return res.data;
    } catch (err: any) {
      if (err.name != "CanceledError") error.value = err;
    } finally {
      isLoading.value = false;
    }
  };

  return {
    request,
    cancelSignal,
    isLoading,
    error,
  };
};
```

```vue
<template></template>
<script setup lang="ts">
import { useAxios, onMounted } from 'src/composable/useTask'
import { requestURL } from "src/utils"
const { request, isLoading, error } = useAxios()

const url = requestURL("/Default/FocusCustomer") // url = http://localhost:53546/Default/FocusCustomer

onMounted(async () => {
  await request({
    method:"get",
    url,
  }).then((res) => {
    ... // res為 http://localhost:53546/Default/FocusCustomer後端回傳的HTML
    let html = $(res)
    let customer = html.find("#DefaultCustomer").text() // 取得id為DefaultCustomer的元素的值 => 拿到客戶選單的選項
    ...
  })
})
</script>

```

如果前端的請求失敗，請檢查:

1. `.env` 中的 `VITE_MVC_PORT` 是否設定正確
2. `.env` 中的 `VITE_PROJECT` 是否設定正確
3. 檢查ASP.NET MVC專案web.config

> system.webServer區塊必須CORS設定

```xml
  <system.webServer>
    ...
    <httpProtocol>
      <customHeaders>
        <add name="Access-Control-Allow-Origin" value="*" />
        <add name="Access-Control-Allow-Headers" value="Content-Type" />
        <add name="Access-Control-Allow-Methods" value="POST,GET" />
      </customHeaders>
    </httpProtocol>
    ...
  </system.webServer>
```

> `*`字號代表任何來源都可以byPass，也可以改成指定的來源，如`http://localhost:5173`

## 6. 加上部屬版本

- 在開發階段是屬於前後端分離的狀況，但發布時會將前端打包的靜態檔案放到後端專案。因此，取得後端資料的區塊，需要加上部屬後的版本。
- 區分開發與部屬版本，主要是透過 `import.meta.env.MODE` 來判斷，如下：

```ts
// pnpm run dev時
import.meta.env.MODE = "development"
const url = requestURL("/Default/FocusCustomer") // url = http://localhost:53546/Default/FocusCustomer
// pnpm run build時
import.meta.env.MODE = "production"
const url = requestURL("/Default/FocusCustomer") // url = http://192.168.5.141:83/TestPPI/Default/FocusCustomer
```

`FocusCustomer.vue`部屬後的不需要透過request取得/Default/FocusCustomer內的資料，因為這個頁面的靜態檔案會連同HTML一起下載到客戶端，如下：

```vue
<template></template>
<script setup lang="ts">
import { useAxios, onMounted } from 'src/composable/useTask'
import { requestURL } from "src/utils"
const { request, isLoading, error } = useAxios()
import $ from 'jquery'
const url = requestURL("/Default/FocusCustomer") // url = http://192.168.5.141:83/TestPPI/Default/FocusCustomer

cosnt init = async () => {
  await request({
    method:"get",
    url,
  }).then((res) => {
    ... // res為 http://localhost:53546/Default/FocusCustomer後端回傳的HTML
    let html = $(res)
    let customer = html.find("#DefaultCustomer").text() // 取得id為DefaultCustomer的元素的值 => 拿到客戶選單的選項
    ...
  })
}

onMounted(async () => {
  // 只有在開發模式時，才需要使用網路請求取得資料
  if (import.meta.env.MODE === "development") {
    await init()
  } else {
    // 部屬模式時，可以直接取得資料
    let customer = $("#DefaultCustomer").text() 
    ...
  }
})
</script>

```

## 7. 數據與組件的綁定

```vue
<template>
  <Select v-model="customer" :options="customerOptions" />
</template>
<script lang="ts" setup>
import Select from "src/components/QSingleSelect.vue"

const customer = ref("")
const customerText = ref("")
const customerOptions = computed(() => {
  if (customerText.value == "") return []
  else {
    return customerText.value.split(";").map((item:string) => {
      let [value, label] = item.split(",")
      return { value, label }
    })
  } 
})


onMounted(async () => {
  if (import.meta.env.MODE === "development") {
    await init()
  } else {
    customer.value = $("#DefaultCustomer").val()
    customerText.value = $("#DefaultCustomer").text()
  }
})

</script>

```
